# -*- coding:utf-8 -*-

# 问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。


class Solution:
    def LastRemaining_Solution(self, n, m):
        if n < 1:
            return -1
        res, i = 0, 2
        while i <= n:
            res = (res + m) % i
            i += 1
        return res


s = Solution()
print s.LastRemaining_Solution(13, 4)


#https://blog.csdn.net/dongyanwen6036/article/details/84892590
    
#由此，得出公式f(n)=(f(n-1)+m)%n,f(1)=0.

https://www.cnblogs.com/wupeixuan/p/8624526.html

    /**
     * 记录一下其中映射关系的由来：
     * n个人排成一排，编号如下：
     * 0,1,2,3,4，.....,n-2,n-1
     * 按照规定，第一个出队的人的编号是 k = (m-1)%n,(对n取余是考虑到m>n的情况)，记最后剩下的人的编号为 F(n, m)
     * 接下来从编号为k+1的人开始报数，相当于如下的编号排列：
     * k+1, k+2, k+3, ...., n-2, n-1, 0, 1, ..., k-2, k-1  ////(*)
     * 对应的映射为：
     * 0, 1, 2, .....,n-k-3, n-k-2, n-k-1, n-k, ...., n-3, n-2  /////(**)
     * 描述这个映射关系的函数为：
     * p(x) = (x+n-k-1)%n, 这里的变量x表示上面数列（*）的元素，p(x) 表示上面数列（**）中相同位置对应的值
     * 然后我们实际上需要的映射是描述 (**)--->(*) 的函数，即为p^(x)
     * 如果找到这样的映射p^(x)，则F(n-1,m)可以通过p^(x)映射到(*)中，即跟F(n, m)建立联系。
     * 因为p(x) = (x+n-k-1)%n,根据取余运算的定义，它等价于 x+n-k-1 = g*n + p(x)，其中g表示某个整数
     * 等式左边移位化简后得：x = (g-1)*n + p(x) + k + 1
     * 注意x代表的是上面数列(*)中的编号，因此x的取值范围为[0,n-1],因此上面的等式需要对n取余，即：
     * x = [(g-1)*n + p(x) + k + 1]%n = [p(x) + k + 1]%n
     * 改写因变量和自变量得到：p^(x) = [x+k+1]%n
     * 上式中的x代表(**)数列中的元素，也即F(n-1,m),将 x = F(n-1, m) 和 k = (m-1)%n 代入即得：
     * F(n, m) = [ F(n-1, m) + (m-1)%n + 1 ]%n
     * 继续化简上式： 由 k=(m-1)%n 得 m-1=j*n+k,得 k = m-1-j*n = (m-1)%n，代入上式：
     * F(n, m) = [ F(n-1, m) + m-1-j*n + 1 ]%n = [ F(n-1, m) + m ]%n
     * 注意 [-j*n]%n = 0
     * 因此递归关系表达式为：F(n, m) = [F(n-1, m)+m]%n 
     */
    
    
思路：
0,1,2,3,4，.....,n-2,n-1剩下的人与k+1, k+2, k+3, ...., n-2, n-1, 0, 1, ..., k-2, k-1剩下的人是一样的，都可描述为F(n, m)
0, 1, 2, .....,n-k-3, n-k-2, n-k-1, n-k, ...., n-3, n-2 剩下的人可描述为F(n-1, m)
又因为上述两有一个映射关系p^(x) = [x+k+1]%n
代入可得F(n, m) = [ F(n-1, m) + (m-1)%n + 1 ]%n
因此递归关系表达式为：F(n, m) = [F(n-1, m)+m]%n
